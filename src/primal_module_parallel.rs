//! Parallel Primal Module
//! 
//! A parallel implementation of the primal module, by calling functions provided by the serial primal module
//!

use super::util::*;
use serde::{Serialize, Deserialize};
use crate::rayon::prelude::*;
use super::primal_module::*;
use super::primal_module_serial::*;
use super::dual_module_parallel::*;
use super::visualize::*;
use super::dual_module::*;
use std::sync::Arc;
use std::ops::DerefMut;


pub struct PrimalModuleParallel {
    /// the basic wrapped serial modules at the beginning, afterwards the fused units are appended after them
    pub units: Vec<PrimalModuleParallelUnitPtr>,
    /// local configuration
    pub config: PrimalModuleParallelConfig,
    /// partition information generated by the config
    pub partition_info: Arc<PartitionInfo>,
    /// thread pool used to execute async functions in parallel
    pub thread_pool: Arc<rayon::ThreadPool>,
}

pub struct PrimalModuleParallelUnit {
    /// the index
    pub unit_index: usize,
    /// the owned serial primal module
    pub serial_module: PrimalModuleSerial,
    /// left and right children dual modules
    pub children: Option<(PrimalModuleParallelUnitWeak, PrimalModuleParallelUnitWeak)>,
    /// parent dual module
    pub parent: Option<PrimalModuleParallelUnitWeak>,
}

pub type PrimalModuleParallelUnitPtr = ArcRwLock<PrimalModuleParallelUnit>;
pub type PrimalModuleParallelUnitWeak = WeakRwLock<PrimalModuleParallelUnit>;

impl std::fmt::Debug for PrimalModuleParallelUnitPtr {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let unit = self.read_recursive();
        write!(f, "{}", unit.unit_index)
    }
}

impl std::fmt::Debug for PrimalModuleParallelUnitWeak {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        self.upgrade_force().fmt(f)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct PrimalModuleParallelConfig {
    /// enable async execution of dual operations; only used when calling top-level operations, not used in individual units
    #[serde(default = "primal_module_parallel_default_configs::thread_pool_size")]
    pub thread_pool_size: usize,
    /// debug by sequentially run the fusion tasks, user must enable this for visualizer to work properly during the execution
    #[serde(default = "primal_module_parallel_default_configs::debug_sequential")]
    pub debug_sequential: bool,
}

impl Default for PrimalModuleParallelConfig {
    fn default() -> Self { serde_json::from_value(json!({})).unwrap() }
}

pub mod primal_module_parallel_default_configs {
    // pub fn thread_pool_size() -> usize { 0 }  // by default to the number of CPU cores
    pub fn thread_pool_size() -> usize { 1 }  // debug: use a single core
    pub fn debug_sequential() -> bool { false }  // by default enabled: only disable when you need to debug and get visualizer to work
}

impl PrimalModuleParallel {

    /// recommended way to create a new instance, given a customized configuration
    pub fn new_config(initializer: &SolverInitializer, partition_info: Arc<PartitionInfo>, config: PrimalModuleParallelConfig) -> Self {
        let mut thread_pool_builder = rayon::ThreadPoolBuilder::new();
        if config.thread_pool_size != 0 {
            thread_pool_builder = thread_pool_builder.num_threads(config.thread_pool_size);
        }
        let thread_pool = thread_pool_builder.build().expect("creating thread pool failed");
        let mut units = vec![];
        let unit_count = partition_info.units.len();
        thread_pool.scope(|_| {
            (0..unit_count).into_par_iter().map(|unit_index| {
                // println!("unit_index: {unit_index}");
                let primal_module = PrimalModuleSerial::new(&initializer);
                PrimalModuleParallelUnitPtr::new_wrapper(primal_module, unit_index)
            }).collect_into_vec(&mut units);
        });
        Self {
            units: units,
            config: config,
            partition_info: partition_info,
            thread_pool: Arc::new(thread_pool),
        }
    }

}

impl PrimalModuleImpl for PrimalModuleParallel {

    fn new(initializer: &SolverInitializer) -> Self {
        Self::new_config(initializer, PartitionConfig::default(initializer).into_info(initializer), PrimalModuleParallelConfig::default())
    }

    fn clear(&mut self) {
        unimplemented!()
    }

    fn load(&mut self, _interface: &DualModuleInterface) {
        panic!("load interface directly into the parallel primal module is forbidden, use `solve` instead");
    }

    fn resolve<D: DualModuleImpl>(&mut self, _group_max_update_length: GroupMaxUpdateLength, _interface: &mut DualModuleInterface, _dual_module: &mut D) {
        panic!("parallel primal module cannot handle global resolve requests, use `solve` instead");
    }

    fn intermediate_matching<D: DualModuleImpl>(&mut self, _interface: &mut DualModuleInterface, _dual_module: &mut D) -> IntermediateMatching {
        unimplemented!()
    }

}

impl PrimalModuleParallel {

    pub fn parallel_solve<DualSerialModule: DualModuleImpl + Send + Sync>
            (&mut self, syndrome_vertices: &Vec<usize>, parallel_dual_module: &mut DualModuleParallel<DualSerialModule>) -> DualModuleInterface {
        self.parallel_solve_step_callback(syndrome_vertices, parallel_dual_module, |_, _, _, _| {})
    }

    pub fn parallel_solve_visualizer<DualSerialModule: DualModuleImpl + Send + Sync + FusionVisualizer>
            (&mut self, syndrome_vertices: &Vec<usize>, parallel_dual_module: &mut DualModuleParallel<DualSerialModule>
            , visualizer: Option<&mut Visualizer>) -> DualModuleInterface {
        if let Some(visualizer) = visualizer {
            let interface = self.parallel_solve_step_callback(syndrome_vertices, parallel_dual_module, |interface, dual_module, primal_module, group_max_update_length| {
                println!("group_max_update_length: {:?}", group_max_update_length);
                if let Some(length) = group_max_update_length.get_none_zero_growth() {
                    visualizer.snapshot_combined(format!("grow {length}"), vec![interface, dual_module, primal_module]).unwrap();
                } else {
                    let first_conflict = format!("{:?}", group_max_update_length.peek().unwrap());
                    visualizer.snapshot_combined(format!("resolve {first_conflict}"), vec![interface, dual_module, primal_module]).unwrap();
                };
            });
            visualizer.snapshot_combined(format!("solved"), vec![&interface, parallel_dual_module, self]).unwrap();
            interface
        } else {
            self.parallel_solve(syndrome_vertices, parallel_dual_module)
        }
    }

    pub fn parallel_solve_step_callback<DualSerialModule: DualModuleImpl + Send + Sync, F: Send + Sync>
            (&mut self, syndrome_vertices: &Vec<usize>, parallel_dual_module: &mut DualModuleParallel<DualSerialModule>, mut callback: F) -> DualModuleInterface
            where F: FnMut(&DualModuleInterface, &DualModuleParallel<DualSerialModule>, &Self, &GroupMaxUpdateLength) {
        let partitioned_syndrome = self.partition_info.partition_syndrome(syndrome_vertices);
        let last_unit_ptr = self.units.last().unwrap().clone();
        let thread_pool = Arc::clone(&self.thread_pool);
        thread_pool.scope(|_| {
            last_unit_ptr.iterative_solve_step_callback(self, &partitioned_syndrome, parallel_dual_module, &mut Some(&mut callback))
        })
    }

}

impl FusionVisualizer for PrimalModuleParallel {
    fn snapshot(&self, abbrev: bool) -> serde_json::Value {
        unimplemented!()
    }
}

impl PrimalModuleParallelUnitPtr {

    /// create a simple wrapper over a serial dual module
    pub fn new_wrapper(serial_module: PrimalModuleSerial, unit_index: usize) -> Self {
        unimplemented!()
        // Self::new(PrimalModuleParallelUnit {
        //     unit_index: unit_index,
        //     serial_module: serial_module,
        // })
    }

    /// call on the last primal node, and it will spawn tasks on the previous ones
    fn iterative_solve_step_callback<DualSerialModule: DualModuleImpl + Send + Sync, F: Send + Sync>(&self, primal_module_parallel: &PrimalModuleParallel
                , partitioned_syndrome: &Vec<Vec<VertexIndex>>, parallel_dual_module: &DualModuleParallel<DualSerialModule>, callback: &mut Option<&mut F>)
            -> DualModuleInterface where F: FnMut(&DualModuleInterface, &DualModuleParallel<DualSerialModule>, &PrimalModuleParallel, &GroupMaxUpdateLength) {
        let mut unit = self.write();
        // only when sequentially running the tasks will the callback take effect, otherwise it's unsafe to execute it from multiple threads
        let debug_sequential = primal_module_parallel.config.debug_sequential;
        if let Some((left_child_weak, right_child_weak)) = unit.children.as_ref() {
            let (left_interface, right_interface) = if debug_sequential {
                let left_interface = left_child_weak.upgrade_force().iterative_solve_step_callback(primal_module_parallel, partitioned_syndrome
                    , parallel_dual_module, callback);
                let right_interface = right_child_weak.upgrade_force().iterative_solve_step_callback(primal_module_parallel, partitioned_syndrome
                    , parallel_dual_module, callback);
                (left_interface, right_interface)
            } else {
                rayon::join(|| {
                    left_child_weak.upgrade_force().iterative_solve_step_callback::<DualSerialModule, F>(primal_module_parallel, partitioned_syndrome
                        , parallel_dual_module, &mut None)
                }, || {
                    right_child_weak.upgrade_force().iterative_solve_step_callback::<DualSerialModule, F>(primal_module_parallel, partitioned_syndrome
                        , parallel_dual_module, &mut None)
                })
            };
            unimplemented!()
        } else {  // this is a leaf, proceed it as normal serial one
            let syndrome_vertices = &partitioned_syndrome[unit.unit_index];
            let dual_module_ptr = parallel_dual_module.get_unit(unit.unit_index);
            let mut dual_module = dual_module_ptr.write();
            unit.serial_module.solve_step_callback(syndrome_vertices, dual_module.deref_mut(), |interface, _dual_module, _primal_module, group_max_update_length| {
                if let Some(callback) = callback.as_mut() {
                    callback(interface, parallel_dual_module, primal_module_parallel, &group_max_update_length);
                }
            })
        }
    }

}

#[cfg(test)]
pub mod tests {
    use super::*;
    use super::super::example::*;
    use super::super::dual_module_serial::*;
    use std::sync::Arc;

    pub fn primal_module_parallel_basic_standard_syndrome_optional_viz<F>(mut code: impl ExampleCode, visualize_filename: Option<String>
            , mut syndrome_vertices: Vec<VertexIndex>, final_dual: Weight, partition_func: F, reordered_vertices: Option<Vec<VertexIndex>>)
            -> (DualModuleInterface, PrimalModuleParallel, DualModuleParallel<DualModuleSerial>) where F: Fn(&SolverInitializer, &mut PartitionConfig) {
        println!("{syndrome_vertices:?}");
        if let Some(reordered_vertices) = &reordered_vertices {
            code.reorder_vertices(reordered_vertices);
            syndrome_vertices = code.translated_syndrome_to_reordered(reordered_vertices, syndrome_vertices);
        }
        let mut visualizer = match visualize_filename.as_ref() {
            Some(visualize_filename) => {
                let mut visualizer = Visualizer::new(Some(visualize_data_folder() + visualize_filename.as_str())).unwrap();
                visualizer.set_positions(code.get_positions(), true);  // automatic center all nodes
                print_visualize_link(&visualize_filename);
                Some(visualizer)
            }, None => None
        };
        // create dual module
        let initializer = code.get_initializer();
        let mut partition_config = PartitionConfig::default(&initializer);
        partition_func(&initializer, &mut partition_config);
        println!("partition_config: {partition_config:?}");
        let partition_info = partition_config.into_info(&initializer);
        let mut dual_module = DualModuleParallel::new_config(&initializer, Arc::clone(&partition_info), DualModuleParallelConfig::default());
        // create primal module
        let mut primal_module = PrimalModuleParallel::new_config(&initializer, Arc::clone(&partition_info), PrimalModuleParallelConfig::default());
        // try to work on a simple syndrome
        code.set_syndrome(&syndrome_vertices);
        let interface = primal_module.solve_visualizer(&code.get_syndrome(), &mut dual_module, visualizer.as_mut());
        assert_eq!(interface.sum_dual_variables, final_dual * 2, "unexpected final dual variable sum");
        (interface, primal_module, dual_module)
    }
    
    pub fn primal_module_parallel_standard_syndrome<F>(code: impl ExampleCode, visualize_filename: String, syndrome_vertices: Vec<VertexIndex>
            , final_dual: Weight, partition_func: F, reordered_vertices: Option<Vec<VertexIndex>>)
            -> (DualModuleInterface, PrimalModuleParallel, DualModuleParallel<DualModuleSerial>) where F: Fn(&SolverInitializer, &mut PartitionConfig) {
        primal_module_parallel_basic_standard_syndrome_optional_viz(code, Some(visualize_filename), syndrome_vertices, final_dual, partition_func, reordered_vertices)
    }

    /// test a simple case
    #[test]
    fn primal_module_parallel_basic_1() {  // cargo test primal_module_parallel_basic_1 -- --nocapture
        let visualize_filename = format!("primal_module_parallel_basic_1.json");
        let syndrome_vertices = vec![39, 52, 63, 90, 100];
        let half_weight = 500;
        primal_module_parallel_standard_syndrome(CodeCapacityPlanarCode::new(11, 0.1, half_weight), visualize_filename, syndrome_vertices, 9 * half_weight, |initializer, _config| {
            println!("initializer: {initializer:?}");
        }, None);
    }


}
